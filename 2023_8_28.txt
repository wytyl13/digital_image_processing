大家好
上回我们了解了python和c++的项目部署，主要是基于yolov5作为引入点，其中涉及到了一些大家在项目部署过程
中的问题。主要可以增加大家在工作和学习中对项目运作的一些了解。我相信大家已经对项目的部署有一个
全面的了解了python和c++已经可以覆盖大家在工作和学习中的大部分任务了。

下来的思路有两个，当然，都是基于图像处理的。
    第一个是深度学习，现在的主流。解决问题的效率很高。算法的效果也很好。
        深度学习强大的特征提取能力可以让它在图像处理方面遥遥领先。图像的一个最重要的特点是其
        局部关联性，我不知道对不对。这个特性让卷积神经网络提取特征很适用。我们不需要去定义
        很多个卷积核，我们不需要去了解每一个卷积核都是提取那部分特征的，是轮廓，是眼睛、是鼻子？
        还是其他图像特征，我们也不需要去考虑那个提取特征应该放在什么位置，那个效果更好，也不需要
        测试很多次去看效果。我们只需要定义一个标签即可，然后让计算机不断地去靠仅这个标签。当然
        靠近标签的基础是我们需要根据特征的模型和任务区定义特定的损失函数。所有中间的过程都由计算机自己
        完成。但是这并不能说明这些中间过程不是我们人类可以控制的。我们当然可以拿出来一个卷积核去看它主要是
        干什么的，任何一个卷积核的效果我们都可以通过具体的卷积核参数来看到。比如，忘记了哈哈，后续咱们再看吧
        其实就是一些有规律的卷积核，比如常用的高斯核等等。当然因为深度学习产业趋势很明显了，并不是每个人
        都会理解每一个卷积核的含义，所以也就说明了为什么深度学习学习到的参数并不是人类可以解释的问题了。
        因为解释起来很麻烦。也没有意义。

        当然深度学习的优势很多，但是也并不一定说明传统算法一无是处，我们所接触到的日常生活中，深度学习
        效率确实很好，但是科学研究探索的时未知领域。有一句话叫做，你的优点就是你的缺点，你的缺点就是你的
        优点，哈哈。
        我们可以从解决问题的方式来分析深度学习和传统算法的差异。
        深度学习的解决思路是结果是已知的，就是说我们使用深度学习去解决的问题一般都是我们在现实生活中已经
        解决的问题，我们只是去提供另一种解决问题的方式。让计算机自己去解决。比如目标检测，自动驾驶
        人类也可以驾驶，这个是已知的一个问题。

        但是传统算法的解决思路是我们通过现有的算法和理论基础去解决一些已知或者未知的问题，
        因为这个解决问题的方法我们人类可以自定义，所以造成了我们的结果的多样性，当然，有好的结果，有
        不好的结果，但是为什么就不相信那一天发现了一个惊世骇俗的结论呢？哈哈，所以我认为，传统算法可以
        推动科学技术的进步，因为传统算法可以很好的和物理学数学等基础科学结合起来。而深度学习主要还是
        对现有问题的一个改进。也就是说深度学习可能并不具备研究未知事物的能力。哈哈，这是我个人意见，
        我只是想说明一下传统算法也很重要。

        为什么传统算法很重要？我想说一点具体的。
        比如我们日常生活中使用的图像，我们使用手机或者相机拍的照片。一般都是可见光成像。
        我们生活在一个充满电磁波的世界中。什么是电磁波。就是这个，哈哈哈
        你可以想象我们在一个由电磁波交织相错的世界中，只是它具有穿透性我们感觉不到。
        你看过太极张三丰吗，最后的打戏张三丰和反派在一张网上面打架，电磁波其实就很想那张网，
        只不过网不是平面，而是有波动的，什么是波，比如水波，
        >>>>>>>>>>>>>>>
        比如我们站在岸边看水波，他是长得这样子，但是实际上我们的视角错误，因为我们的眼睛和水波不再一个视角。
        他其实是这样的。当你的视角和水波向平的时候，那才是真正的波。我们就生活在一个波的世界
        波有两个主要概念，一个是电磁波的频率，一个波长。频率和波长是对立的概念，也即他俩肯定是一个高一个低
        好了，电磁波会根据波长和频率的不同分为好几种
        我们日常生活中常见的是可见过，它的波长和频率处于中间位置，我忘记了，我查下吧
        但是基本上是这样的，伽马射线的波长最短，频率最高。无线电的波长最长，频率最低。
        太阳就会发出很多的伽马射线。你可以想象一下伽马射线的频率，如果高频率的电磁波经过你会有一个
        什么感觉？哈哈，想想一下，伽马射线经过你的身体，你有什么感觉？
        伽马射线 ->  X光 -> 可见光 -> 无线电
        好吧，这些是电磁波的一些常识，为什么要说这些呢？我想说的是我们的日常生活中图像只是更加
        切合人类视觉的一个工具，有很多的物质存在我们周围。当然，我们可以多不同波段的电磁波进行成像
        这些是完全可以的，比如B超，X光等等，这些经常应用于医疗中。但是对于我们，要跨越通过图像作为媒介
        去处理一些现实问题。比如蝙蝠是如何去判断方向的，我想它不是通过眼睛去看的，虽然它也有眼睛
        但是它还是通过超声波去判断方向的，也就是说我们虽然有视觉系统，但是我们不一定需要成像到视觉系统
        中去解决我们的问题，特别是对于机器来说。比如太空探索、飞机等等。

        也就是说图像处理只是我们基于图像去解决现实问题的一个手段，如果我们拘泥于图像处理，那么有些复杂的问题
        我们就很难解决。那么基于此，深度学习较传统算法就表现乏力了。传统算法因为和物理学数学很好的结合
        它完全可以在这些未知领域超越深度学习。我相信咱们国家一定会出现这样的人才。实现弯道超车，超越科技
        发达的国家。




    第二个是传统的图像处理算法。就我目前的认知来看，传统算法和深度学习算法对于解决现实问题来说
    当然，我可能接触到的现实问题都是一些日常生活的，但是对于日常生活问题的解决能力，特别是互联网
    相关的问题，深度学习因为基于庞大的数据作为基础，它的效果可以甩掉传统算法几条街。哈哈
    但是并不是说传统算法一无是处，在图像处理方面，传统算法在日常生活的应用却是很少，但是在工业级
    应用上，比如图像压缩、一些未知领域的探索方面，效果还是很好的。


    好吧，说了那么多，总结一下，主要想说明两点：
        深度学习在日常生活中表现出很强的优势
        传统算法对于未知领域的探索尤为重要
        所以后续我们要基于这两个方向去学习

        首先对于深度学习的学习，我们在掌握了模型的部署以后，首先要处理的时模型的复现，也即代码实现
        其次我们要在现有模型的基础上做研究，探讨更加深层次的高效的模型

        对于传统算法，我们不能放弃，我们需要深入研究，从数字图像处理入手，超过图像处理，实现
        对未知领域的探索。
    最后，忠告大家一下。科学研究虽然很迷人，但是人生也很美好。如果大家对这方面很感兴趣，希望可以
    得到更好的发展，大家可以深入学习。但是如果大家需要很多的时间忙自己的人生，那么大家谨慎入坑。
    我觉得最好的解决人生烦恼的办法不是学习，而是一无所知。。。。
    最后推荐两本书，也是后续需要参考的教材
        第一本：数字图像处理 冈萨雷斯
        第二本：深入理解计算机系统 布莱恩特

    第一本书是传统图像处理算法的，第二本书是在项目中需要用到的一些基础知识。
    好了，未完待续。。。。。下面我们将开始从数字图像处理开始，也即传统算法。




OK下面开始数字图像处理

数字图像处理，顾名思义，是对数字的处理。我们将可见光成像后，可以通过多种方式展示它
现在被普遍使用的是图像数字化，即将数字和对应的图像展示进行编码，将图像以数字的形式保存在
电脑内存中。我们所有的处理是在数字这块，即是我们基于电脑中的所有图像都可以获取到它的数字形式
然后我们通过对数字进行处理。至于图像的展示就是一个编码解码的过程。比如机器信息的表示。
10  十进制，在机器中就是
0000 1010
这个就是数字10在电路中的存储方式。数字图像的展示也一样。

图像处理的方式有多种，但是至少可以分为以下两大类
    第一是根据图像处理的结果不同可以分类为图像到图像，也即pixel to pixel.和模式识别，也即分类等等任务
    也即我们的结果不是想要一张图像。
        电脑卡，卡的时候我暂停吧
    第二是根据图像的处理形式不同，我不知道这个描述正确吗。我说下具体内容大家应该可以理解。
        图像的计算机存储是矩阵的形式，比如一张灰度图像，就是一个二维数组，每个数组中存储多个像素值
        然后我们基于该原始灰度值去处理的方式称为空间域处理。
        1 2 3
        2 3 4
        4 5 6

        比如这是一张图像，我们基于该原始图像像素值去处理就是空间域处理，然后我们可以基于该原始图像
        空间域进行变化，变换后的称之为变换域，最经典的比如快速傅里叶变化后的就是频率域。基于频率域
        的图像处理，然后将频率域回溯到空间域。
        这个就是基于不同形式图像的处理，不同的形式处理是为了解决不同的问题，空间域是最基本的处理方式，
        变换域可以解决空间域难以处理的一些问题。

    因此一个图像处理问题，我们首先可以归类一下。是pixel to pixel，是否需要使用变换域处理
    我们首先从最简单的问题入手，pixel to pixel,并且在空间域处理图像。最典型的是图像增强技术

    下面我们从图像增强入手。
        我们先来了解下图像的存储和使用方式，基于opencv，当然我们可以使用c++或者python
        本方案基于c++，大家可以在python上试验。
        图像的存储方式和一个简单的数据类型的存储一样，我们首先需要确定图像存储的数据类型。
        图像是以数组的形式存储的。每个数组由一个个数据组成，我们首先需要明确数组的类型
        常用的数据类型有
        unsigned int      4bytes
        unsigned char     1bytes
        我确定下unsigned char是不是1个字节
        这里注意无符号和有符号的区别，计算机的存储需要考虑到最大数据占用的内存大小。
        注意这里我们不考虑32还是64位的了，如果大家需要详细了解这部分内容可以参考数字图像处理
        好吧，上面的没有毛病，我们先来看着两种数据类型吧
        一个unsigned int可以存储的最大数值是多少呢，一个字节是8比特，一个比特位是计算电路存储
        的最小单位 0 1
                        binary                   十进制     n
        0000 0000 0000 0000 0000 0000 0000 0000 -> 0       -
        0000 0000 0000 0000 0000 0000 0000 0001 -> 1        0
        0000 0000 0000 0000 0000 0000 0000 0010 -> 2        1
        0000 0000 0000 0000 0000 0000 0000 0011 -> 3        1,0
        0000 0000 0000 0000 0000 0000 0000 0100 -> 4        2
        好吧，我们先看这五个数值，从右往左开始是小端法。我们归总下计算方式，十进制到二进制的转换
        从右侧开始，从0开始，每个位对应的索引位n,不考虑全为0的，比特位全为0的就是十进制就是0
        2^0 = 1
        2^1 = 2
        2^1 + 2^0 = 3
        2^2 = 4
        然后我们考虑下已知比特位的情况下的最大值，即
        1111 1111 1111 1111 1111 1111 1111 1111 = 2^(32-1) = 4,294,967,296 - 1 = 4,294,967,295
        这样看起来比较麻烦，我们根据一个8比特的来总结下规律吧

        0000 0000 = 0
        1111 1111 = 1+2+4+8+16+32+64+128 = 255 = 2^(8) - 1
        也即某一个比特下最大的信息表示可以是2^n-1.注意我想计算下
        这就是无符号整型和char的信息表示，注意无符号和有符号是有区别的。我们在数字图像这块都是无符号，
        不涉及到有符号的存储。
        下面我们考虑下8比特数据
        8比特的最大信息表示是255，最小是0，可以表示256个数值。数字图像处理中一般使用8比特作为存储数据的
        基本单位，为什么首先要考虑下数字的存储呢？因为这个和图像紧密结合，而且涉及到后续的图像的存储
        和转换等如果数据类型错误，会出现很多的存储问题。
            8比特图像存储的 意思是可以将一个灰度图像。
                灰度图像就是一个二维数组表示的图像，我们可以使用一个二维数组来表示一个灰度图像
                我们可以将一个灰度图像从纯黑到纯白等分为256分，即从0-255，每个等分表示一个像素值
                如果等分的分数越多，可以表示的图像信息就越多，图像内容就越丰富，比如我们可以使用
                unsigned int去等分纯黑到纯白的灰度图。4,294,967,295比256是不是可以表示的信息更加丰富？
                当然，8比特已经足够了，毕竟我们还需要处理的复杂度和存储的问题
        好吧我们现在来基于8比特的图像来开始我们的图像处理程序吧。
            我们基于opencv来构建图像处理程序，所有的图像存储都是使用opencv的图像数据类型Mat来处理
            我们先来构建一个基础的opencv项目
            我直接复制过来了。
            我们基于mingw编译项目
            提示没有搜索到任何cpp文件，我们可以先定义一个

            OK,配置的时候还是有很多问题的，但是大家一定要有耐心
            计算机虽然复杂但是却很稳定。我们下来创建一个8bit的图像
            然后基于这个图像来做点事情。
                我们已经创建了一张8比特的单通道图像，我们可以
                多创建几张，然后将其合并为一张三通道图像，其实就是
                物理意义上的拼接，如果可以使用numpy，就是创建一个
                3*width*height的数组。


            我们拼接了一张三通道的图像，其实就是物理意义上的拼接。
            当然我们可以使用Mat直接去构建一个三通道的图像，哈哈
            为什么这么麻烦，其实还是想着重表达一下任何一个三通道的问题
            都可以转换为一个个单通道的问题。解决灰度图像的问题是解决
            彩色图像的基础。

            下面我们正式开始灰度图像的变换
                灰度图像的变换包含多种，基于不同的目的有不同的变换方式。
                对比度增强是一种基本的图像增强方案。
                通过对图像像素的一系列处理可以增强图像的对比度
                对比度即图像的像素值的在不同区间范围的分布情况。高对比度
                是图像的像素值之间有很大的差别，可以很好的区分图像的细节
                0 1 1 2 3 2 3 3 4 5 20 222 250 250
                如上列表，加入是一张图像，最左边和最右侧的对比度是最高的，一黑壹白
                区分度很高，可以看到图像中更多的细节，而如果一个图像区域全是分布较
                均匀的像素值，2 3 2 3 3比如这个区域如果是一个物体，那么这个物体的细节
                将不会被很好的显示。后续我们基于不同的对比度增强方案来深入了解

                灰度直方图是灰度图像的一个很好的统计形式，通过对图像的每个像素值
                在整张图像中出现的概率做统计，然后基于该统计量去调整图像的原始像素值，使得
                图像的分布更加均均衡化是一个很好的对比度增强方案。
                    下面我们了解灰度直方图均衡化。
                    后续我们的函数创建还是基于头文件和实现文件，这样我们可以很好的将主函数
                    分离出来。
                    使用命名空间可以让我们的代码更加简洁，命名空间就类似于python中的module

                    这块注意一下函数中返回指针或者变量的问题。这个问题一般在python获取高级的
                    语言中不存在，在C/C++中很常见，注意一下函数栈的运行方式
                    注意getDistribution这个函数的调用会形成一个新的栈帧，该函数中所有的
                    变量都会在该函数运行结束后释放。在return以后释放。此时如果我们的返回值是一个
                    数值，也就是不是指针类型的数据，指针就是一个内存地址。主函数中定义的变量
                    会直接接受该数值。这个没有问题。但是如果我们接受的是一个指针，那么主函数中的
                    指针变量也同样会接受该指针，但是需要注意的是，这个内存是在栈帧中开辟的，
                    栈帧被释放后改内存也会被释放，所以造成了我们刚才的情况，内存根本就不存在了
                    更不要提数值了。解决办法只有一个，那就是在栈帧中去定义指针变量在堆区。
                    不再执行栈中定义变量，而在堆区定义变量，堆区的变量在程序执行结束前都不会被
                    释放，你可以理解为在主函数执行结束之前都不会被释放。malloc在堆区申请内存。

                    我们已经得到的灰度图像的分布，然后我们基于该分步计算灰度直方图均衡化

                    好了就是这么简单，我们编译下
                    很明显出现错误了，我们检查下
                    看来不是这个问题
                    可以发现从之前的比较暗的图像变为较亮的图像
                    可以理解为一点，对比度增强会将暗色图像变为亮色
                    将亮色图像变为暗色，可以这样理解，随着后续的
                    灰度图像变换算法的增加我们会更深有体会。我们来比较下这两张图像吧。
                    直接从之前的项目复制一下，这个和我们的图像处理相关性不大。
                    OK，我们看到图像增强的效果还是可以的，至少我们可以看到更多的细节，但是
                    值得注意的是。增强后的图像并不是我们想要的，因为存在失真的现象，比如
                    石头还有两边的墙壁太亮了，我们并不是需要整张图像的亮度更高，而是
                    想要该亮的部分更亮，不该亮的地方不要变得那么亮。哈哈
                    后续我们继续。
                    未完待续。。。。。


大家好
上个视频我们了解了直方图均衡化处理操作，这次我们来了解直方图规定化处理
直方图操作是基于图像像素值分布的，这里我们需要将像素值的分布和图像区分开来。我们是基于像素的
分布值去将直方图均衡化的。因为分布值是固定的，对于一幅图像来说，只能得到一个均衡化的直方图
而不同的图像也可能对应同一个均衡化后的直方图。比如。
这两张图像的分布是相同的，他们均衡化后的直方图也是相同的

对于直方图的处理，我们主要是基于它去进行图像对比度的提升。主要有两个思路
    第一：我们可以给定一个已有分布，然后让输入图像的直方图去靠近他。
        这个就是我们本次要了解的直方图规定化，我们可以给定一个已知的像素值分布规律，让图像的
        分布去趋近于这个规律。当然，这个分布怎么来，我们可以自己去定义，也可以从一张现有的
        图像中计算得到。为了深入了解直方图规定化的处理，我们有必要对之前的均衡化操作做进一步了解
        因为规定化的操作是基于均衡化，也可以理解为均衡化就是规定化的一个特殊处理方式。
        直方图规定化，我们的思想是让原始图像的分布尽可能的接近某一个给定的分布。这有一个前提假设
        我们需要使用到直方图均衡化的一个特点，就是相同图像均衡化后的结果相同。大概是这样的
        比如我们对原始图像进行均衡化
            equalization_input = T(r), r是原始灰度值
        假设我们现在已有一个对原始图像规定化后的结果，这个结果是我们想要的，那么它的均衡化后的结果应该
        和原始图像均衡化后的结果一样。
            equalization_object = G(z), z是我们想要得到的图像的灰度值，也就是新的映射灰度值
        根据图像均衡化的特点，相同图像均衡化的结果应该一致。
            equalization_input = equalization_object = T(r) = G(z)。
        那么现在问题变得简单了，已知r求解z，T和G对应的都是均衡化的表达式。即
            z = G(z)的反函数
        那么我们可以通过求解均衡化表达式的反函数来计算得到z值。但是我们一般不这样做，我们并不需要精确
        的z值，我们只需要一个无限接近的z值，这个z值的分布无限接近于我们给定的分布.那么现在问题又进一步简化为
        我们需要再minimize(T(r) - G(z))的条件下求解z值。
        T(r) = (L - 1) * ∫0_255(P_r)dr
        G(z) = (L - 1) * ∫0_255(P_z)dz
        minimize((L - 1) * ∫0_255(P_r)dr - (L - 1) * ∫0_255(P_z)dz) = 
        minimize(∫0_255(P_r)dr - ∫0_255(P_z)d)
        这个公式已经很简单了。P_r是原始图像的像素值，对应的分布是原始图像的分布
        P_z是我们要得到的图像的像素值，对应的分布是我们给定的。我们只需要求解这两个积分的差值，使得差值最小化
        即可。这两个积分是什么？其实就是我们在计算直方图规定化中的一个累计分布。
        我们可以称之为累计概率分布，分别对应的原始图像的累计概率分布和我们给定的分布的累计概率分布。
        然后我们求解对应的差值，找到最小的差值对应的值，就是对原始图像的映射值，这个映射值就是z值。我们求解的
        下面让我们开始。


    第二，就是一些直方图映射函数的定义，特殊的比如直方图均衡化处理。
        直方图均衡化可以让图像变量。大概是这样的我们看个简单的例子
            我们拿一个3比特的图像来看下直方图均衡化
            不好意思，晚上了，脑袋有点蒙计算错误，重来。
            大概计算方式就是这样的，最后的计算结果就是对原始灰度值的映射，可以发现整体的灰度值都提升了。
            灰度直方图均衡化处理后的结果大概是这样的。可以起到一个拉伸的效果，所以灰度直方图的适用范围
            是对低灰度值的图像的处理。
            好了，现在来看规定化

编译下，晚上脑袋你有点蒙，思路不是特别清晰，大家见谅
    好了，应该是没有问题我们继续.
    我们已经定义好了规定化函数，我们测试下把
    找一张图像，我们需要用它获取规定的分布
    效果不是很好，我们检查下函数中是否错误
    应该是累计概率分布那块计算错误了，我排除下、我暂停下找下问题
    这个结果左上角是原始图像，右下角是图像均衡化的结果，右上角是我们的目标图像，我们使用了它的分布
    左下角是直方图规定化后的结果，其分布和右上角图像的概率分布无限接近。
    可以发现，直方图规定可以很好的解决均衡化对图像亮度过度增强的效果。因为均衡化针对的时全局的
    像素值，所以一些细节方面做的不到位。我们可以对三通道图像均衡化和规定化看看效果。

    我怎么感觉这个规定化的三通道的效果不是特别好，应该有问题我再看下


    左上角是原始图像，右上角是object图像
    左下角是均衡化后的彩色图像，右下角是原始图像按照object图像的概率分布得到的
    规定化后的图像，可以看到直方图均衡化主要是增强图像的亮度。而规定化则更注意图像的颜色细节。
    不是整体亮度的增强。规定化适用性更强一点。固定化主要还是参考了object图像的分布，可以用于更换图像的主题。
    好了，今天就到这里，后面的结尾处耽搁了很长时间，抱歉。
    下歌视频我们继续进行灰度值的变换，考虑更完美的变换。



    大家好，上次我们了解了直方图规定化的处理。我们继续深入了解
    不论直方图均衡化还是直方图规定化，我们都是针对整个图像灰度值分布进行的处理。
    这有时候并不是我们需要的。直方图变换操作会使得图像的灰度值更均衡，均衡的意思即
    将图像的灰度值范围扩散为0-255之间。其实就是起到了灰度值拉伸的效果。一般情况下我们将0-100之间的灰度值称为低亮度
    将100-150之间的灰度值称之为低对比度，150以上的是高亮度灰度值。我们要处理的就是低对比度区域的灰度值，因为这部分区域的
    灰度值映射出来的图像不黑不白，对比度较低。所以这就是灰度直方图操作的一个目的。提高对比度。

    下面我们基于图像局部的分布进行灰度变换，我们之前都是基于全局分布进行的灰度变换，全局还是局部只是我们对图像灰度变换的一种方式
    它适用于均衡化、规定化等等灰度变换。下面我们来简单了解下局部分布。

    注意这是一个简单的灰度图像，我们之前定义灰度映射图都是基于全局分布计算得到的。也即我们要定义0灰度值的映射，我们
    首先计算整张图像每个灰度值的分布，然后基于该分布计算累计概率分布，然后计算不同的映射。
    现在我们希望通过一个扫描框，扫描当前像素值附近的固定区域，我们需要基于该子区域计算映射图。而不是基于整张图像计算
    好了，下面我们开始定义局部操作

    OK我们定义好了局部操作，我们测试下。
    注意因为我们使用了嵌套循环所以这里很慢。稍微等下，后续我们使用多线程优化循环
    我们可以计算下我们的循环次数
    751*500 = 375,500，至少循环这么多次，并且每循环一次要计算一次子图的累计概率分布
    并且扫描的步伐是1，所以这里注意核尺寸越大对应耗费的时间越大，因为循环的次数不变，但是计算累计概率分布的时间增加了。
    可以发现效果并不是很好，这是因为我们的扫描区域很小的问题，当然也和我们要解决的图像增强问题有关，这个图像可能不适合
    自适应（局部）直方图操作。我们尝试下加大扫描尺寸，大家可以试下增加步伐试下效果。可以发现如果尺寸过大，会造成
    图像黑边的效果，其实也不完全是黑边，是原始图像没有进行映射的部分。我们可以在图像的周围添加像素点来解决这个问题。
    我们稍后使用添加像素点的方法去解决这个问题。
        我们可以使用多线程解决循环耗费时间长的问题。
        时间很长，我们了解下多线程把。线程起初是windows的概念，linux只有进程这个概念。linux是进程安全的，
        windows上的进行不安全。但是windows线程安全。线程是cpu调度的最小单元。也就是cpu可以分身处理每一个线程。
        但是注意，cpu并不是同步执行每一个线程的，而是在每一个线程间进行切换，这个称作上下文切换。
        我们先来了解下线程，这个对后续的程序优化极为重要。
        一个进程大家可以理解为一个软件，也可以理解为一个主函数。进程有独立运行的虚拟内存。
        大概就是这样的，线程是cpu调度的最小单元。线程可以理解为我们可以在一个软件中同时操作多个操作，这个不冲突
        进程可以理解为我们可以在一台电脑上开启多个软件，也不冲突。进程之间互相独立，但是线程之间共享虚拟内存
        也就意味着我们可以在一个函数栈中创建多个线程来共同管理一个变量。比如我们可以同时创建多个子区域
        去改变同一个Mat，然后生成对应的输出图像。这里注意线程理论上是没有上限的，只要你创建的线程数不超过
        你的运行内存大小，当然，CPU的调度极限是有的，这取决于你的硬件核数的大小，CPU调度是上下文切换，不是同时进行
        虽然线程数量取决于运行内存的大小，但是也要考虑CPU的负载。所以我们可以将对一张图像的循环操作
        交给多个线程去处理，这样来增加我们的速度。比如我们处理一张图像花费15分钟，那么我们创建15个线程
        ，这样我们可以使用大约1分钟去处理，CPU进行上下文切换我们感觉不到，

        比如一个shell程序就是一个进程。我们咋shell中输入内容

        .\DIGITAL_IMAGE_PROCESSING.exe shell进程会监听读取我们输入的内容。当我们输入回车以后
        CPU将shell进程挂起，然后开启DIGITAL_IMAGE_PROCESSING.exe这个可执行程序的进程，当然这个进程中我们可能会调用了
        多个线程。当该进程执行完毕或者返回值后，CPU结束该进程，进行上下文切换，然后将返回的内容交给shell。shell进程继续进行
        这个上下文切换我们感觉不到卡顿。

        下面我们对图像做填充操作，。
        很慢，因为for循环本来就慢。如果可以进行矩阵的乘法就可以使用并行运算了。
        应该是没有问题了，竟然运行了63秒。大家可以试下其他的灰度处理方法，比如可以试下规定化，道理是一样的
        我们下个视频使用多线程的思想提高下程序的运行速度。这个运行速度和C++不符。哈哈



大家好，上个视频我们了解了灰度直方图的局部操作也就是自适应处理
其中有很多问题我们还没有解决，我们本次视频了解下如何通过多线程来提升
灰度均衡化自适应处理的效率问题。因为我们需要使用自定义的扫描尺寸去原始图像中
扫描对应的区域，然后根据对应区域的直方图指标去计算映射值，我们的思想是
使用一个奇数尺寸去扫描，然后更改根据扫描区域设置对应的中心点的灰度值的映射值。

如刚才的图所示，我们会逐步进行扫描，然后计算每一次扫描的灰度直方图均衡化映射图
然后根据映射图去修改每一次扫描到的中心点，注意，如果我们不做任何处理，映射后的图像
将会缩小2*half_length_size,这里的half_length_size是我们定义的扫描尺寸的一半
注意扫描尺寸需要是奇数。这里的一半向下取整，因为我们使用了int类型去接受该一般尺寸指标
所以直接就是向下取整操作。然后上个视频我们为了不缩小扫描后的图像的尺寸，我们使用
0填充的方法去解决了这个问题，通过对每个边（上下左右）填充half_length_size大小的边
我们可以很好的解决这个问题

但是上个视频我们提出了一个问题,就是通过多线程的思想去提升扫描的效率,
我们的想法是将原始图像分为n个线程去处理,每一个线程同步执行对应的扫描操作,
我们的想法是这样的...
    现成之间共享内存,所以我们可以让每一个线程都去操作同一个地址的图像.

下面我们开始
    我根据线程索引值定义了当前线程的原点和宽高，但是我们发现出现了问题
    只有x在一直改变y一直没有改变，我们预测是判断条件除了问题。

    注意我们是针对的padding后的图像，然我们先把这个改过来
    但是和这个
    ok，我们已经定义好了线程灰度直方图操作函数，和对应的线程函数
    下来我们测试

注意我们是简单化了该函数，我们没有考虑不能整除部分
可以发现除了宽高定义的问题。我们排查下
我们已经让主线程阻塞等待子线程执行结束后再执行，但是还是报错
那么就是线程函数中定义错了。

注意问题是我们没有定义outputImage,但是我们在主函数中去打印它了
是线程函数出现问题了
这个结果是有问题的，我们排查下。。
回宿舍了，没有空调，电脑散热困难，有点卡
我测试下多线程的使用比单线程的速度提升多少，按照道理是开几个线程会快几倍
但是还需要考虑CPU的调度问题。如果线程较多，cpu的上下文切换会消耗时间，到最后反而速度回下降
所以每台电脑都有自己的线程上限。

好吧我们已经定义好了多线程函数，但是我们还需要将简单问题复杂化。
我们需要考虑不能被整除的部分，这会影响到图像的结果，因为未被整除部分一般很小，所以我们在结果图像
上一般很难发现，但是有时候我们还需要去考虑未被整除部分对图像结果的影响，比如我们想要更改
0填充为其他填充的时候，因为我们定义的是多线程操作，最右侧和最下侧的未被整除部分将不会被处理。
这样效果不会体现在最右侧和最下侧。未被整除部分我们之前已经了解了。
多线程处理应该是没有问题了，就是我们最后没有对outputimage去掉padding，所以看到的图像有黑边的效果

为了规范化传入线程个数，也因为我我们没有对不能整除线程做兼容，我们可以定义枚举类去进行线程数传参。
我们可以发现，使用多线程却是可以加快程序的运行效率，但是我们使用多线程
处理的问题还是直方图均衡化，当然我们也可以使用规定化，但是多线程
去提升局部处理的主要目的还是想要通过图像的局部统计量来进行灰度值变换
我们之前所有的操作都是基于局部区域的直方图进行的操作，我们是对整个图像
进行的扫描，我们可以看下效果。我们会扫描每一个局部区域，然后根据局部
区域的直方图分布去进行每一个扫描区域中心像素的映射，这将会改变图像
中的每一个像素，如果我们使用padding的情况下。如上图
图像整体会变白，但是我们想要的效果我们希望我们 可以有条件的去改变
图像的像素，比如我们会扫描每一个局部区域，然后根据该局部区域的统计
指标相对于整体的统计指标而言，是否满足我们定义的一些条件去有条件的
改变图像区域，因此我们所要做的操作是直方图统计量变换，当然条件
是局部区域的统计量相对于全局而言的。基于直方图计算的一些统计量
就是直方图统计量。当然也可以有其他统计量，比如我们可以定义一个
空间滤波器，然后通过计算该空间滤波器和对应图像扫描区域的一些指标
比如线性指标或者其他指标，我们可以基于该统计量去有条件的改变图像
中某一个区域的像素。这是我们希望的。
注意这里我们提到了一个名词，空间滤波，我们后续深入了解。
我们可以观看该结果图像
比如这两个区域，我们是不希望它进行直方图均衡化处理的，因为处理后的
结果会失真，所以我们可以根据统计量变换去达到这个要求。我们
后续了解直方图统计量变换。
double k[4] = {0.0, 0.08, 0.06, 0.19};


上个视频我们提出了使用直方图统计量作为对更改图像像素值的条件。因为我们可能在实际解决问题的时候
会遇到我们仅想要增强地灰度值区域保留高灰度值区域的情况
注意灰度直方图的一些处理主要是为了解决低对比度的问题。我们之前已经了解了，对比度增强主要是
将低对比度区间的灰度值映射到0-255， 因为低对比度区间的灰度值不易区分，容易隐藏很多图像中的细节
但是有时候我们只想对图像地灰度值区域的像素点进行增强。所以我们可以使用基于直方图计算得到的一些统计量
去作为是否更改图像像素点的条件，即我们可以根据这些统计量筛选出我们想要处理的地灰度值的区域。而忽略
哪些高灰度值的区域。
我们之前还了解了局部直方图处理的操作，根据测试的经验和数学规律，我们可以很简单的发现，当局部扫描区域
的尺寸越大的时候，图像映射到高灰度值的几率越大，也就是说扫描尺寸越大，对应的图像亮度增强的越大。
基于此，我们可以通过改变扫描尺寸的大小去修改增强的程度，当然，因为扫描区域越大，扫描到的高灰度值
的概率就越大，对应的计算得到的映射值就越大。

下面我们开始灰度直方图统计量变换
    我们需要基于直方图去计算一些统计量，常用的统计量有均值，标准差，方差等等
    注意，如果每个灰度值出现的概率是相等的，我们不需要基于直方图去计算这些统计量
    但是因为每个灰度值在图像中出现的概率是随机的，所以我们需要基于该直方图去计算统计量
    我们使用常用的均值和方差去筛选我们需要改变的图像区域。
        均值，通过均值我们可以设置一个范围，比如我们可以设置扫描图像的均值在整个图像均值的某一个范围
        内我们才对其进行灰度变换操作，具体的灰度变换可以是均衡化、规定化、指数变换等等

        方差，通过方差，我们可以筛选出扫描区域图像像素差异区间，我们可以设置扫描图像的方差在整个图像
        方差的某一个范围内我们才进行映射操作。当然，可以是均衡化等等
    
        基于此，我们需要定义一个均值范围，一个方差范围，这个范围是基于全局均值和方差计算的
        然后再进行映射变换操作前，我们需要判断扫描区域的均值和方差是否在该范围内。
        G_mean, G_variance, 分别对应全局均值和方差
        L_mean, L_variance, 分别对应局部均值和方差
        我们需要指定范围，该范围作为全局均值和方差的因子
        min_mean, max_mean, min_variance, max_variance.
        L_mean >= min_mean * G_mean ......就是做这些判断
    
    然后我们需要制定变换操作，我哦们之前已经了解了均衡化、规定化。但是这里我们仅仅是想要对低灰度值
    进行增强，因此我们可以直接将对应的灰度值乘以一个常数，该常数一般是全局图像的最大灰度值/局部图像的最大
    灰度值。
那么到此准备工作就完成了，因为是局部操作，所以我们完全可以基于上次定义的线程局部操作函数去定义
灰度直方图统计量变换。
下面我们开始
好吧，函数还挺长，大家可以考虑下是否可以使用递归来优化下之前定义的多线程函数。因为这个函数
太长了。

我们直接基于之前定义的函数去定义灰度直方图统计量变换吧，我们只需要更改线程函数即可。
我们已经定义好了获取对应图像的均值和方差的函数，测试下
OK，没有问题我们继续
注意这个报错是线程函数调用报错了，只有一种原因，函数参数定义出错
好了，结束了，统计量操作的适用性还是很强的。

未完待续。。。。


大家好，本次视频我们了解下一些常规的灰度变换函数，我们之前
进行的灰度变换操作都是基于灰度直方图的变换。
    常规的函数包含线性和非线性的
    线性的，比如灰度反转,对应的8比特图像
        y = -x + 255
    非线性的比如对数变换、指数变换等等
    我们参考数字图像处理原书实现下这些变换。
首先了解下图像反转。
    注意L是2^n，n是图像的比特数，比如8比特图像的L就是256
    也就是8比特图像反转函数的截距项是255
    这样的变换可以将图像中的灰度值进行反转变换，也即原来的低灰度
    转换为高灰度，高灰度转换为低灰度，斜率是-1。
    可以发现图像的反转其实就是将原来的低灰度转换为高灰度，高灰度转换为低灰度
    比如原书中对病灶的处理，有些情况下病灶为低灰度，非病灶区域为高灰度更能凸显
    细节。
非线性变换较少，对于阈值处理函数，他可以基于一个制定的灰度界线，将低于该界线
的灰度和高于该界线的灰度区分开，我们一般将该方法定义为二值函数，也即将低于界线
的灰度值置为0，高于界线的灰度值置为1.
我们定义下该函数。我们已经定义了反转变换、二值变换和线性缩放函数
下面我们考虑对数变换和指数变换。
下面我们来实现对数变换，对数变换中我们可以通过改变C值的大小来调整图像的亮度，一般来说
C值越大，图像的亮度越小。
可以发现对数变换可以将图像的整体亮度提升，我们可以通过c参数来调整图像亮度提升的程度
可以发现调整C值的大小却是可以干预对数变换对图像的亮度的提升效果

下面我们来定义幂律变换，也就是伽马变换，伽马变换是最通用的函数变换，反转和对数变换都是伽马变换的特殊形式
我们使用伽马变换可以更高的调节图像变量的程度。
    但是注意伽马变换的主要特点还是我们可以通过伽马值的大小去调整图像的亮度
    可以发现伽马值越大，对图像亮度的提升效果越小，但是条件式伽马值在0-1之间
    当伽马值为1的时候等同于同等变换
    当伽马值大于1的时候刚好相反
可以看出来伽马变换的通用性和效果更好，我们可以使用伽马变换来达到不同的亮度提升效果
注意范围在0-1之间可以提升图像的亮度。随着伽马值的增加，亮度提升效果越小。
可以发现伽马值在0-1范围内，伽马值越小对亮度的提升效果越好。伽马变换的优势是通用性，当伽马值在1以上的时候，
伽马变换会降低图像的灰度值，如上式案例，降低某些区域的灰度值可以更好的显示图像的细节。

还有一种变换是分段线性变换，其实就是阈值变换的一个加强版，只不过分段线性变换是基于两个点来对
变换函数进行定义的。两个点就可以对函数进行分段。大家后续可以自行定义该函数，

好了我们已经了解和基本的函数变换，我们来了解下灰度级分层
    灰度级分层的意思是，不论是多大比特的图像，我们都可以按照比特位来划分图像层级
    按照比特位划分层级的意思是比如8比特图像，我们考虑划分1比特位，那意味着2^1=2-1=1
    0,1灰度值以外的像素点全部置为0
    8比特位就是2^8-1=255， 2^7=128,128-255之间的灰度值保持原样，其余的灰度值全部置为0

    可以发现，8比特图像保存着图像的大部分信息，因为图像的一些细节主要是靠高灰度值体现的，而8
    比特反应的正是图像的高灰度值区间。
    我们可以基于这种思想将图像划分为不同的比特层级，不同的比特层级保存着图像不同的特征信息
    这个和卷积神经网络在特征提取方面有着相似的地方。
    比特分层可以用于图像压缩，因为我们完全可以使用比特层级去复原一张原始图像，当然，我们可以使用
    最高的比特层级去近似复原一张原始图像，这样我们可以使用少量的数据去保存该原始图像。这就是图像
    压缩的核心思想。下面我们来定义比特层级函数。
    可以发现最大的比特层保存了图像基本所有的信息，而低比特层则保存了一些细节信息，比如边框，轮廓等

好了灰度变换就到这了
    我们首先基于直方图了解了灰度变换
    然后最后一节了解了一些基本的灰度变换函数。
    这些都足够我们去进行图像增强或者预处理了
下面我们来了解一些空间变换，因为之前我们都是基于图像像素本身的一些规律或者常规函数做的变换
后续我们需要引入滤波，即在之前扫描原始图像的基础上，考虑一个外在的核去进行灰度变换
我们将首先从简单的仿射变换做起。仿射变换即基于图像的一些旋转、缩放、裁剪等等预处理为目的
而滤波则有更高深的意味。

未完待续。。。。


















































































































































        


        
















































