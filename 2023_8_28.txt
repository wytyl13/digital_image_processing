大家好
上回我们了解了python和c++的项目部署，主要是基于yolov5作为引入点，其中涉及到了一些大家在项目部署过程
中的问题。主要可以增加大家在工作和学习中对项目运作的一些了解。我相信大家已经对项目的部署有一个
全面的了解了python和c++已经可以覆盖大家在工作和学习中的大部分任务了。

下来的思路有两个，当然，都是基于图像处理的。
    第一个是深度学习，现在的主流。解决问题的效率很高。算法的效果也很好。
        深度学习强大的特征提取能力可以让它在图像处理方面遥遥领先。图像的一个最重要的特点是其
        局部关联性，我不知道对不对。这个特性让卷积神经网络提取特征很适用。我们不需要去定义
        很多个卷积核，我们不需要去了解每一个卷积核都是提取那部分特征的，是轮廓，是眼睛、是鼻子？
        还是其他图像特征，我们也不需要去考虑那个提取特征应该放在什么位置，那个效果更好，也不需要
        测试很多次去看效果。我们只需要定义一个标签即可，然后让计算机不断地去靠仅这个标签。当然
        靠近标签的基础是我们需要根据特征的模型和任务区定义特定的损失函数。所有中间的过程都由计算机自己
        完成。但是这并不能说明这些中间过程不是我们人类可以控制的。我们当然可以拿出来一个卷积核去看它主要是
        干什么的，任何一个卷积核的效果我们都可以通过具体的卷积核参数来看到。比如，忘记了哈哈，后续咱们再看吧
        其实就是一些有规律的卷积核，比如常用的高斯核等等。当然因为深度学习产业趋势很明显了，并不是每个人
        都会理解每一个卷积核的含义，所以也就说明了为什么深度学习学习到的参数并不是人类可以解释的问题了。
        因为解释起来很麻烦。也没有意义。

        当然深度学习的优势很多，但是也并不一定说明传统算法一无是处，我们所接触到的日常生活中，深度学习
        效率确实很好，但是科学研究探索的时未知领域。有一句话叫做，你的优点就是你的缺点，你的缺点就是你的
        优点，哈哈。
        我们可以从解决问题的方式来分析深度学习和传统算法的差异。
        深度学习的解决思路是结果是已知的，就是说我们使用深度学习去解决的问题一般都是我们在现实生活中已经
        解决的问题，我们只是去提供另一种解决问题的方式。让计算机自己去解决。比如目标检测，自动驾驶
        人类也可以驾驶，这个是已知的一个问题。

        但是传统算法的解决思路是我们通过现有的算法和理论基础去解决一些已知或者未知的问题，
        因为这个解决问题的方法我们人类可以自定义，所以造成了我们的结果的多样性，当然，有好的结果，有
        不好的结果，但是为什么就不相信那一天发现了一个惊世骇俗的结论呢？哈哈，所以我认为，传统算法可以
        推动科学技术的进步，因为传统算法可以很好的和物理学数学等基础科学结合起来。而深度学习主要还是
        对现有问题的一个改进。也就是说深度学习可能并不具备研究未知事物的能力。哈哈，这是我个人意见，
        我只是想说明一下传统算法也很重要。

        为什么传统算法很重要？我想说一点具体的。
        比如我们日常生活中使用的图像，我们使用手机或者相机拍的照片。一般都是可见光成像。
        我们生活在一个充满电磁波的世界中。什么是电磁波。就是这个，哈哈哈
        你可以想象我们在一个由电磁波交织相错的世界中，只是它具有穿透性我们感觉不到。
        你看过太极张三丰吗，最后的打戏张三丰和反派在一张网上面打架，电磁波其实就很想那张网，
        只不过网不是平面，而是有波动的，什么是波，比如水波，
        >>>>>>>>>>>>>>>
        比如我们站在岸边看水波，他是长得这样子，但是实际上我们的视角错误，因为我们的眼睛和水波不再一个视角。
        他其实是这样的。当你的视角和水波向平的时候，那才是真正的波。我们就生活在一个波的世界
        波有两个主要概念，一个是电磁波的频率，一个波长。频率和波长是对立的概念，也即他俩肯定是一个高一个低
        好了，电磁波会根据波长和频率的不同分为好几种
        我们日常生活中常见的是可见过，它的波长和频率处于中间位置，我忘记了，我查下吧
        但是基本上是这样的，伽马射线的波长最短，频率最高。无线电的波长最长，频率最低。
        太阳就会发出很多的伽马射线。你可以想象一下伽马射线的频率，如果高频率的电磁波经过你会有一个
        什么感觉？哈哈，想想一下，伽马射线经过你的身体，你有什么感觉？
        伽马射线 ->  X光 -> 可见光 -> 无线电
        好吧，这些是电磁波的一些常识，为什么要说这些呢？我想说的是我们的日常生活中图像只是更加
        切合人类视觉的一个工具，有很多的物质存在我们周围。当然，我们可以多不同波段的电磁波进行成像
        这些是完全可以的，比如B超，X光等等，这些经常应用于医疗中。但是对于我们，要跨越通过图像作为媒介
        去处理一些现实问题。比如蝙蝠是如何去判断方向的，我想它不是通过眼睛去看的，虽然它也有眼睛
        但是它还是通过超声波去判断方向的，也就是说我们虽然有视觉系统，但是我们不一定需要成像到视觉系统
        中去解决我们的问题，特别是对于机器来说。比如太空探索、飞机等等。

        也就是说图像处理只是我们基于图像去解决现实问题的一个手段，如果我们拘泥于图像处理，那么有些复杂的问题
        我们就很难解决。那么基于此，深度学习较传统算法就表现乏力了。传统算法因为和物理学数学很好的结合
        它完全可以在这些未知领域超越深度学习。我相信咱们国家一定会出现这样的人才。实现弯道超车，超越科技
        发达的国家。




    第二个是传统的图像处理算法。就我目前的认知来看，传统算法和深度学习算法对于解决现实问题来说
    当然，我可能接触到的现实问题都是一些日常生活的，但是对于日常生活问题的解决能力，特别是互联网
    相关的问题，深度学习因为基于庞大的数据作为基础，它的效果可以甩掉传统算法几条街。哈哈
    但是并不是说传统算法一无是处，在图像处理方面，传统算法在日常生活的应用却是很少，但是在工业级
    应用上，比如图像压缩、一些未知领域的探索方面，效果还是很好的。


    好吧，说了那么多，总结一下，主要想说明两点：
        深度学习在日常生活中表现出很强的优势
        传统算法对于未知领域的探索尤为重要
        所以后续我们要基于这两个方向去学习

        首先对于深度学习的学习，我们在掌握了模型的部署以后，首先要处理的时模型的复现，也即代码实现
        其次我们要在现有模型的基础上做研究，探讨更加深层次的高效的模型

        对于传统算法，我们不能放弃，我们需要深入研究，从数字图像处理入手，超过图像处理，实现
        对未知领域的探索。
    最后，忠告大家一下。科学研究虽然很迷人，但是人生也很美好。如果大家对这方面很感兴趣，希望可以
    得到更好的发展，大家可以深入学习。但是如果大家需要很多的时间忙自己的人生，那么大家谨慎入坑。
    我觉得最好的解决人生烦恼的办法不是学习，而是一无所知。。。。
    最后推荐两本书，也是后续需要参考的教材
        第一本：数字图像处理 冈萨雷斯
        第二本：深入理解计算机系统 布莱恩特

    第一本书是传统图像处理算法的，第二本书是在项目中需要用到的一些基础知识。
    好了，未完待续。。。。。下面我们将开始从数字图像处理开始，也即传统算法。




OK下面开始数字图像处理

数字图像处理，顾名思义，是对数字的处理。我们将可见光成像后，可以通过多种方式展示它
现在被普遍使用的是图像数字化，即将数字和对应的图像展示进行编码，将图像以数字的形式保存在
电脑内存中。我们所有的处理是在数字这块，即是我们基于电脑中的所有图像都可以获取到它的数字形式
然后我们通过对数字进行处理。至于图像的展示就是一个编码解码的过程。比如机器信息的表示。
10  十进制，在机器中就是
0000 1010
这个就是数字10在电路中的存储方式。数字图像的展示也一样。

图像处理的方式有多种，但是至少可以分为以下两大类
    第一是根据图像处理的结果不同可以分类为图像到图像，也即pixel to pixel.和模式识别，也即分类等等任务
    也即我们的结果不是想要一张图像。
        电脑卡，卡的时候我暂停吧
    第二是根据图像的处理形式不同，我不知道这个描述正确吗。我说下具体内容大家应该可以理解。
        图像的计算机存储是矩阵的形式，比如一张灰度图像，就是一个二维数组，每个数组中存储多个像素值
        然后我们基于该原始灰度值去处理的方式称为空间域处理。
        1 2 3
        2 3 4
        4 5 6

        比如这是一张图像，我们基于该原始图像像素值去处理就是空间域处理，然后我们可以基于该原始图像
        空间域进行变化，变换后的称之为变换域，最经典的比如快速傅里叶变化后的就是频率域。基于频率域
        的图像处理，然后将频率域回溯到空间域。
        这个就是基于不同形式图像的处理，不同的形式处理是为了解决不同的问题，空间域是最基本的处理方式，
        变换域可以解决空间域难以处理的一些问题。

    因此一个图像处理问题，我们首先可以归类一下。是pixel to pixel，是否需要使用变换域处理
    我们首先从最简单的问题入手，pixel to pixel,并且在空间域处理图像。最典型的是图像增强技术

    下面我们从图像增强入手。
        我们先来了解下图像的存储和使用方式，基于opencv，当然我们可以使用c++或者python
        本方案基于c++，大家可以在python上试验。
        图像的存储方式和一个简单的数据类型的存储一样，我们首先需要确定图像存储的数据类型。
        图像是以数组的形式存储的。每个数组由一个个数据组成，我们首先需要明确数组的类型
        常用的数据类型有
        unsigned int      4bytes
        unsigned char     1bytes
        我确定下unsigned char是不是1个字节
        这里注意无符号和有符号的区别，计算机的存储需要考虑到最大数据占用的内存大小。
        注意这里我们不考虑32还是64位的了，如果大家需要详细了解这部分内容可以参考数字图像处理
        好吧，上面的没有毛病，我们先来看着两种数据类型吧
        一个unsigned int可以存储的最大数值是多少呢，一个字节是8比特，一个比特位是计算电路存储
        的最小单位 0 1
                        binary                   十进制     n
        0000 0000 0000 0000 0000 0000 0000 0000 -> 0       -
        0000 0000 0000 0000 0000 0000 0000 0001 -> 1        0
        0000 0000 0000 0000 0000 0000 0000 0010 -> 2        1
        0000 0000 0000 0000 0000 0000 0000 0011 -> 3        1,0
        0000 0000 0000 0000 0000 0000 0000 0100 -> 4        2
        好吧，我们先看这五个数值，从右往左开始是小端法。我们归总下计算方式，十进制到二进制的转换
        从右侧开始，从0开始，每个位对应的索引位n,不考虑全为0的，比特位全为0的就是十进制就是0
        2^0 = 1
        2^1 = 2
        2^1 + 2^0 = 3
        2^2 = 4
        然后我们考虑下已知比特位的情况下的最大值，即
        1111 1111 1111 1111 1111 1111 1111 1111 = 2^(32-1) = 4,294,967,296 - 1 = 4,294,967,295
        这样看起来比较麻烦，我们根据一个8比特的来总结下规律吧

        0000 0000 = 0
        1111 1111 = 1+2+4+8+16+32+64+128 = 255 = 2^(8) - 1
        也即某一个比特下最大的信息表示可以是2^n-1.注意我想计算下
        这就是无符号整型和char的信息表示，注意无符号和有符号是有区别的。我们在数字图像这块都是无符号，
        不涉及到有符号的存储。
        下面我们考虑下8比特数据
        8比特的最大信息表示是255，最小是0，可以表示256个数值。数字图像处理中一般使用8比特作为存储数据的
        基本单位，为什么首先要考虑下数字的存储呢？因为这个和图像紧密结合，而且涉及到后续的图像的存储
        和转换等如果数据类型错误，会出现很多的存储问题。
            8比特图像存储的 意思是可以将一个灰度图像。
                灰度图像就是一个二维数组表示的图像，我们可以使用一个二维数组来表示一个灰度图像
                我们可以将一个灰度图像从纯黑到纯白等分为256分，即从0-255，每个等分表示一个像素值
                如果等分的分数越多，可以表示的图像信息就越多，图像内容就越丰富，比如我们可以使用
                unsigned int去等分纯黑到纯白的灰度图。4,294,967,295比256是不是可以表示的信息更加丰富？
                当然，8比特已经足够了，毕竟我们还需要处理的复杂度和存储的问题
        好吧我们现在来基于8比特的图像来开始我们的图像处理程序吧。
            我们基于opencv来构建图像处理程序，所有的图像存储都是使用opencv的图像数据类型Mat来处理
            我们先来构建一个基础的opencv项目
            我直接复制过来了。
            我们基于mingw编译项目
            提示没有搜索到任何cpp文件，我们可以先定义一个

            OK,配置的时候还是有很多问题的，但是大家一定要有耐心
            计算机虽然复杂但是却很稳定。我们下来创建一个8bit的图像
            然后基于这个图像来做点事情。
                我们已经创建了一张8比特的单通道图像，我们可以
                多创建几张，然后将其合并为一张三通道图像，其实就是
                物理意义上的拼接，如果可以使用numpy，就是创建一个
                3*width*height的数组。


            我们拼接了一张三通道的图像，其实就是物理意义上的拼接。
            当然我们可以使用Mat直接去构建一个三通道的图像，哈哈
            为什么这么麻烦，其实还是想着重表达一下任何一个三通道的问题
            都可以转换为一个个单通道的问题。解决灰度图像的问题是解决
            彩色图像的基础。

            下面我们正式开始灰度图像的变换
                灰度图像的变换包含多种，基于不同的目的有不同的变换方式。
                对比度增强是一种基本的图像增强方案。
                通过对图像像素的一系列处理可以增强图像的对比度
                对比度即图像的像素值的在不同区间范围的分布情况。高对比度
                是图像的像素值之间有很大的差别，可以很好的区分图像的细节
                0 1 1 2 3 2 3 3 4 5 20 222 250 250
                如上列表，加入是一张图像，最左边和最右侧的对比度是最高的，一黑壹白
                区分度很高，可以看到图像中更多的细节，而如果一个图像区域全是分布较
                均匀的像素值，2 3 2 3 3比如这个区域如果是一个物体，那么这个物体的细节
                将不会被很好的显示。后续我们基于不同的对比度增强方案来深入了解

                灰度直方图是灰度图像的一个很好的统计形式，通过对图像的每个像素值
                在整张图像中出现的概率做统计，然后基于该统计量去调整图像的原始像素值，使得
                图像的分布更加均均衡化是一个很好的对比度增强方案。
                    下面我们了解灰度直方图均衡化。
                    后续我们的函数创建还是基于头文件和实现文件，这样我们可以很好的将主函数
                    分离出来。
                    使用命名空间可以让我们的代码更加简洁，命名空间就类似于python中的module

                    这块注意一下函数中返回指针或者变量的问题。这个问题一般在python获取高级的
                    语言中不存在，在C/C++中很常见，注意一下函数栈的运行方式
                    注意getDistribution这个函数的调用会形成一个新的栈帧，该函数中所有的
                    变量都会在该函数运行结束后释放。在return以后释放。此时如果我们的返回值是一个
                    数值，也就是不是指针类型的数据，指针就是一个内存地址。主函数中定义的变量
                    会直接接受该数值。这个没有问题。但是如果我们接受的是一个指针，那么主函数中的
                    指针变量也同样会接受该指针，但是需要注意的是，这个内存是在栈帧中开辟的，
                    栈帧被释放后改内存也会被释放，所以造成了我们刚才的情况，内存根本就不存在了
                    更不要提数值了。解决办法只有一个，那就是在栈帧中去定义指针变量在堆区。
                    不再执行栈中定义变量，而在堆区定义变量，堆区的变量在程序执行结束前都不会被
                    释放，你可以理解为在主函数执行结束之前都不会被释放。malloc在堆区申请内存。

                    我们已经得到的灰度图像的分布，然后我们基于该分步计算灰度直方图均衡化

                    好了就是这么简单，我们编译下
                    很明显出现错误了，我们检查下
                    看来不是这个问题
                    可以发现从之前的比较暗的图像变为较亮的图像
                    可以理解为一点，对比度增强会将暗色图像变为亮色
                    将亮色图像变为暗色，可以这样理解，随着后续的
                    灰度图像变换算法的增加我们会更深有体会。我们来比较下这两张图像吧。
                    直接从之前的项目复制一下，这个和我们的图像处理相关性不大。
                    OK，我们看到图像增强的效果还是可以的，至少我们可以看到更多的细节，但是
                    值得注意的是。增强后的图像并不是我们想要的，因为存在失真的现象，比如
                    石头还有两边的墙壁太亮了，我们并不是需要整张图像的亮度更高，而是
                    想要该亮的部分更亮，不该亮的地方不要变得那么亮。哈哈
                    后续我们继续。
                    未完待续。。。。。


大家好
上个视频我们了解了直方图均衡化处理操作，这次我们来了解直方图规定化处理
直方图操作是基于图像像素值分布的，这里我们需要将像素值的分布和图像区分开来。我们是基于像素的
分布值去将直方图均衡化的。因为分布值是固定的，对于一幅图像来说，只能得到一个均衡化的直方图
而不同的图像也可能对应同一个均衡化后的直方图。比如。
这两张图像的分布是相同的，他们均衡化后的直方图也是相同的

对于直方图的处理，我们主要是基于它去进行图像对比度的提升。主要有两个思路
    第一：我们可以给定一个已有分布，然后让输入图像的直方图去靠近他。
        这个就是我们本次要了解的直方图规定化，我们可以给定一个已知的像素值分布规律，让图像的
        分布去趋近于这个规律。当然，这个分布怎么来，我们可以自己去定义，也可以从一张现有的
        图像中计算得到。为了深入了解直方图规定化的处理，我们有必要对之前的均衡化操作做进一步了解
        因为规定化的操作是基于均衡化，也可以理解为均衡化就是规定化的一个特殊处理方式。
        直方图规定化，我们的思想是让原始图像的分布尽可能的接近某一个给定的分布。这有一个前提假设
        我们需要使用到直方图均衡化的一个特点，就是相同图像均衡化后的结果相同。大概是这样的
        比如我们对原始图像进行均衡化
            equalization_input = T(r), r是原始灰度值
        假设我们现在已有一个对原始图像规定化后的结果，这个结果是我们想要的，那么它的均衡化后的结果应该
        和原始图像均衡化后的结果一样。
            equalization_object = G(z), z是我们想要得到的图像的灰度值，也就是新的映射灰度值
        根据图像均衡化的特点，相同图像均衡化的结果应该一致。
            equalization_input = equalization_object = T(r) = G(z)。
        那么现在问题变得简单了，已知r求解z，T和G对应的都是均衡化的表达式。即
            z = G(z)的反函数
        那么我们可以通过求解均衡化表达式的反函数来计算得到z值。但是我们一般不这样做，我们并不需要精确
        的z值，我们只需要一个无限接近的z值，这个z值的分布无限接近于我们给定的分布.那么现在问题又进一步简化为
        我们需要再minimize(T(r) - G(z))的条件下求解z值。
        T(r) = (L - 1) * ∫0_255(P_r)dr
        G(z) = (L - 1) * ∫0_255(P_z)dz
        minimize((L - 1) * ∫0_255(P_r)dr - (L - 1) * ∫0_255(P_z)dz) = 
        minimize(∫0_255(P_r)dr - ∫0_255(P_z)d)
        这个公式已经很简单了。P_r是原始图像的像素值，对应的分布是原始图像的分布
        P_z是我们要得到的图像的像素值，对应的分布是我们给定的。我们只需要求解这两个积分的差值，使得差值最小化
        即可。这两个积分是什么？其实就是我们在计算直方图规定化中的一个累计分布。
        我们可以称之为累计概率分布，分别对应的原始图像的累计概率分布和我们给定的分布的累计概率分布。
        然后我们求解对应的差值，找到最小的差值对应的值，就是对原始图像的映射值，这个映射值就是z值。我们求解的
        下面让我们开始。


    第二，就是一些直方图映射函数的定义，特殊的比如直方图均衡化处理。
        直方图均衡化可以让图像变量。大概是这样的我们看个简单的例子
            我们拿一个3比特的图像来看下直方图均衡化
            不好意思，晚上了，脑袋有点蒙计算错误，重来。
            大概计算方式就是这样的，最后的计算结果就是对原始灰度值的映射，可以发现整体的灰度值都提升了。
            灰度直方图均衡化处理后的结果大概是这样的。可以起到一个拉伸的效果，所以灰度直方图的适用范围
            是对低灰度值的图像的处理。
            好了，现在来看规定化

编译下，晚上脑袋你有点蒙，思路不是特别清晰，大家见谅
    好了，应该是没有问题我们继续.
    我们已经定义好了规定化函数，我们测试下把
    找一张图像，我们需要用它获取规定的分布
    效果不是很好，我们检查下函数中是否错误
    应该是累计概率分布那块计算错误了，我排除下、我暂停下找下问题
    这个结果左上角是原始图像，右下角是图像均衡化的结果，右上角是我们的目标图像，我们使用了它的分布
    左下角是直方图规定化后的结果，其分布和右上角图像的概率分布无限接近。
    可以发现，直方图规定可以很好的解决均衡化对图像亮度过度增强的效果。因为均衡化针对的时全局的
    像素值，所以一些细节方面做的不到位。我们可以对三通道图像均衡化和规定化看看效果。

    我怎么感觉这个规定化的三通道的效果不是特别好，应该有问题我再看下


    左上角是原始图像，右上角是object图像
    左下角是均衡化后的彩色图像，右下角是原始图像按照object图像的概率分布得到的
    规定化后的图像，可以看到直方图均衡化主要是增强图像的亮度。而规定化则更注意图像的颜色细节。
    不是整体亮度的增强。规定化适用性更强一点。固定化主要还是参考了object图像的分布，可以用于更换图像的主题。
    好了，今天就到这里，后面的结尾处耽搁了很长时间，抱歉。
    下歌视频我们继续进行灰度值的变换，考虑更完美的变换。




















































        


        
















































