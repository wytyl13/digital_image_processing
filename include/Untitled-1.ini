

现在我们需要对灰度值进行变换，我们希望他变成我们更需要的
那么怎么变换是个问题
    我们可以定义一个函数去将原始灰度值映射到一个新的灰度值。但是如何定义是一个问题
    下面我们有两种特殊办法。
        第一，我们是否可以使用参照图像的灰度值分布规律去映射现有的图像
            我们已知两张图像的灰度值分布。
            如何让输入图像的灰度值分布无限接近于参照图像呢？
            distribution_input = T(r)
            distribution_object = G(z)
            distribution_input = distribution_object
            T(r) = G(z)， 我们的目标是求解z，即z是原始像素值r的映射灰度值
            r是已知的，求解G的反函数即可得到z值。
            这里我们看下我们不必要精确到求反函数的值，只需要使得T(r)无限接近于G(z)即可，
            即在minimize(T(r) - G(z))的条件下求z值
            T(r)是原始图像的均衡化表达式
                (L -1) * ∫0_255(P_r)dr
            G(z)是什么呢？是我们需要求解的z图像的均衡化表达式
                (L -1) * ∫0_255(P_z)dz
            minimize ((L -1) * ∫0_255(P_r)dr - (L -1) * ∫0_255(P_z)dz) = 
            minimize (∫0_255(P_r)dr - ∫0_255(P_z)dz)
            r是原始图像的灰度值，z是目标图像的灰度值。
            目标函数的分布是什么？我们需要确定。。。。。我们可以定义一个0-255灰度值的分布
            用该分布生成对应的图像，也可以给定一张图像的分布。
            所以现在问题化简为了我们需要求解分布最小化下的z值。






            我们的目的是让两个分布无限接近的情况下，去计算新的映射，即改变r的值。
            我们只需要有一个概念就是无限让T(r) - G(z)接近0即可。
            即minimize(T(r) - G(z)), r是原始图像的灰度值，z是参照图像的灰度值





        第二，就是我们上次降到的我们可以使用直方图均衡化，即我们定义了一个函数去映射

        以上就是两种思想，但是值得注意的是，第一个办法实现起来貌似很难。